/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package stacksAndQueues;

import NodesPackage.KAryNode;
import NodesPackage.TNode;
import finalTerm.MergeSort;
import finalTerm.QuickSort;

import finalTerm.SortInsertion;
import finalTerm.hashTable.CommonWord;
import finalTerm.hashTable.HashTable;
import finalTerm.hashTable.LeftJoins;
import graphs.Vertex;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;

class AppTest {
  // Can successfully push onto a stack
    @Test void pushTest() {
      StackAsLinkedList stack= new StackAsLinkedList();
      stack.push(1);

assertEquals(1,stack.getTop().getData());

    }
    // Can successfully push multiple values onto a stack :

  @Test void pushMultiTest() {
    StackAsLinkedList stack= new StackAsLinkedList();
    stack.push(2);
    stack.push(1);

    assertEquals(1,stack.getTop().getData());

  }
// Can successfully pop off the stack
  @Test void popTest() {
    StackAsLinkedList stack= new StackAsLinkedList();
    stack.push(3);
    stack.push(5);
    assertEquals(5,stack.pop());

  }
  //Can successfully empty a stack after multiple pops
  @Test void isEmptyTest() {
    StackAsLinkedList stack= new StackAsLinkedList();
    stack.push(3);
    stack.push(5);
    stack.pop();
    stack.pop();
    assertEquals(true,stack.isEmpty());

  }
// Can successfully peek the next item on the stack
@Test void peekTest() {
  StackAsLinkedList stack= new StackAsLinkedList();
  stack.push(3);
  stack.push(5);
  assertEquals(5,stack.peek());}


// Calling pop or peek on empty stack raises exception :
@Test void popExceptionTest() {
  StackAsLinkedList stack= new StackAsLinkedList();

  Throwable exception = assertThrows(EmptyStackException.class, () -> stack.pop());

}
  @Test
  void enqueueTest() {
    Queue queue = new Queue();
    queue.enqueue(1);

    assertEquals(1, queue.getFront().getData());

  }

  // Can successfully enqueue multiple values into a queue
  @Test
  void enqueuehMultiTest() {
    Queue queue = new Queue();
    queue.enqueue(1);
    queue.enqueue(8);
    queue.enqueue(11);

    assertEquals(1, queue.getFront().getData());
  }

  // Can successfully dequeue out of a queue the expected value

  @Test
  void dequeueTest() {
    Queue queue = new Queue();
    queue.enqueue(1);
    queue.enqueue(8);
    queue.enqueue(11);

    assertEquals(1, queue.dequeue());
  }

  // Can successfully peek into a queue, seeing the expected value :
  @Test
  void peekQueueTest() {
    Queue queue = new Queue();
    queue.enqueue(1);
    queue.enqueue(8);
    queue.enqueue(11);

    assertEquals(1, queue.peek());
  }

  // Can successfully empty a queue after multiple dequeues :
  @Test
  void multiDequeuesTest() {
    Queue queue = new Queue();
    queue.enqueue(1);
    queue.enqueue(8);
    queue.enqueue(11);
    queue.dequeue();
    queue.dequeue();
    queue.dequeue();
    assertEquals(true
      , queue.isEmpty());
  }

  // Can successfully instantiate an empty queue
  @Test
  void instantiateTest() {
    Queue queue = new Queue();
    queue.enqueue(4);
    queue.enqueue(6);

    assertEquals("{4} ->{6} ->Null", queue.toString());
  }

  // Calling dequeue or peek on empty queue raises exception
  @Test
  void exceptionTest() {
    Queue queue = new Queue();

    Throwable exception = assertThrows(NoSuchElementException.class, () -> queue.peek());
  }
}


class StackTest {


}

class peusodoQueueTest{
  @Test void deQueueTest(){
    PseudoQueue q1= new PseudoQueue();
    q1.enQueue(28);
    q1.enQueue(7);
    q1.enQueue(11);
    assertEquals(q1.deQueue(),28);
  }


  @Test void enQueueTest(){
    PseudoQueue q1= new PseudoQueue();
    q1.enQueue(28);
    q1.enQueue(7);
    q1.enQueue(11);
    q1.deQueue();
    q1.deQueue();
assertEquals(q1.deQueue(),11);
  }



  }
class AnimalShelterTest {
  @Test
  public void testAnimalShelterConstructor() {
    AnimalShelter animalShelter = new AnimalShelter();
    assertEquals(new ArrayList<>(), animalShelter.animals);
  }

  @Test
  public void testAnimalShelterEnqueue() {
    AnimalShelter animalShelter = new AnimalShelter();
    Dogs dog1 = new Dogs("Scooby");
    animalShelter.enqueue(dog1);
    Cats cat2 = new Cats("Garfield");
    animalShelter.enqueue(cat2);
    Cats cat3 = new Cats("HelloKitty");
    animalShelter.enqueue(cat3);
    Dogs dog4 = new Dogs("Scrappy");
    animalShelter.enqueue(dog4);

    assertEquals(4, animalShelter.animals.size());
    assertTrue(animalShelter.animals.contains(cat2));
    assertEquals(dog4, animalShelter.animals.get(animalShelter.animals.size() - 1));
  }

  @Test
  public void testAnimalShelterDequeue() {
    AnimalShelter animalShelter = new AnimalShelter();
    Dogs dog1 = new Dogs("Scooby");
    animalShelter.enqueue(dog1);
    Cats cat2 = new Cats("Garfield");
    animalShelter.enqueue(cat2);
    Cats cat3 = new Cats("HelloKitty");
    animalShelter.enqueue(cat3);
    Dogs dog4 = new Dogs("Scrappy");
    animalShelter.enqueue(dog4);

    assertEquals(dog1.getName(), animalShelter.dequeue("dog").getName());
    assertEquals(dog4.getName(), animalShelter.dequeue("dog").getName());
  }

  @Test
  public void testAnimalShelterDequeueNull() {
    AnimalShelter animalShelter = new AnimalShelter();
    Dogs dog1 = new Dogs("Scooby");
    animalShelter.enqueue(dog1);
    Cats cat2 = new Cats("Garfield");
    animalShelter.enqueue(cat2);
    Cats cat3 = new Cats("HelloKitty");
    animalShelter.enqueue(cat3);
    Dogs dog4 = new Dogs("Scrappy");
    animalShelter.enqueue(dog4);


    assertNull(animalShelter.dequeue("bird"));
  }
}

class bracketTest {

  @Test
  public  void bracketValidationTest(){
    String expr = "(](";
    BracketBalance s1 = new BracketBalance();
    System.out.println(s1.bracketValidation(expr));
assertFalse(s1.bracketValidation(expr));
  }
}


class MaxValTest {
  @Test
  public  void  maxValTesting (){
    StackAsLinkedList<Integer> s1 = new StackAsLinkedList<>() ;
    s1.push(2);
    s1.push(4);
    s1.push(26);
    s1.push(6);
    s1.push(8);
    s1.push(11);
    maxStack m = new maxStack();
    int x = m.maxNum(s1);
    assertEquals(26,x);
  }
}




class TreeBinaryTest {

  @Test

  public void testBinaryTreeInOrder() {
    TNode binaryTreeNode = new TNode(4);
    binaryTreeNode.setLeft(new TNode(2));
    binaryTreeNode.setRight(new TNode(6));

    BinaryTree binaryTree = new BinaryTree(binaryTreeNode);

    binaryTree.getRoot().getLeft().setLeft(new TNode(1));
    binaryTree.getRoot().getLeft().setRight(new TNode(3));
    binaryTree.getRoot().getRight().setLeft(new TNode(5));
    binaryTree.getRoot().getRight().setRight(new TNode(7));
    ArrayList<Integer> expected = new ArrayList<>();
    expected.add(1);
    expected.add(2);
    expected.add(3);
    expected.add(4);
    expected.add(5);
    expected.add(6);
    expected.add(7);
// expected 1,2,3,4,5,6,7
    assertEquals(expected, binaryTree.inOrder(binaryTreeNode));
  }

  @Test
  public void preOrderTest() {
    TNode binaryTreeNode = new TNode(4);
    binaryTreeNode.setLeft(new TNode(2));
    binaryTreeNode.setRight(new TNode(6));

    BinaryTree binaryTree = new BinaryTree(binaryTreeNode);

    binaryTree.getRoot().getLeft().setLeft(new TNode(1));
    binaryTree.getRoot().getLeft().setRight(new TNode(3));
    binaryTree.getRoot().getRight().setLeft(new TNode(5));
    binaryTree.getRoot().getRight().setRight(new TNode(7));
    ArrayList<Integer> expected = new ArrayList<>();
    expected.add(4);
    expected.add(2);
    expected.add(1);
    expected.add(3);
    expected.add(6);
    expected.add(5);
    expected.add(7);
    assertEquals(expected, binaryTree.preOrder(binaryTreeNode));


  }

  @Test
  public void postOrderTest() {
    TNode binaryTreeNode = new TNode(4);
    binaryTreeNode.setLeft(new TNode(2));
    binaryTreeNode.setRight(new TNode(6));

    BinaryTree binaryTree = new BinaryTree(binaryTreeNode);

    binaryTree.getRoot().getLeft().setLeft(new TNode(1));
    binaryTree.getRoot().getLeft().setRight(new TNode(3));
    binaryTree.getRoot().getRight().setLeft(new TNode(5));
    binaryTree.getRoot().getRight().setRight(new TNode(7));

    ArrayList<Integer> expected = new ArrayList<>();
    expected.add(1);
    expected.add(3);
    expected.add(2);
    expected.add(5);
    expected.add(7);
    expected.add(6);
    expected.add(4);
    assertEquals(expected, binaryTree.postOrder(binaryTreeNode));

  }
@Test
  public void searchTreeTest() {
    TNode node = new TNode(2);
    BinarySearchTree binarySearchTree = new BinarySearchTree(node);
    binarySearchTree.add(3);
    binarySearchTree.add(5);
    binarySearchTree.add(7);
    binarySearchTree.add(11);


  }
  @Test
  public void maxValTest (){
    TNode node = new TNode(2);
    BinaryTree binaryTree= new BinaryTree(node);
    node.setRight(new TNode(4));
    node.setLeft(new TNode(9));
    node.getLeft().setRight(new TNode(11));
    node.getLeft().setLeft(new TNode(14));
    node.getRight().setRight(new TNode(1));
    node.getRight().setLeft(new TNode(50));


    assertEquals(50,    binaryTree.findMaxVal());
  }

  @Test
  void breadthTraversalTest(){
    BinaryTree tree = new BinaryTree();
    TNode node = new TNode(1);
    node.setRight(new TNode(4));
    node.setLeft(new TNode(9));
    node.getLeft().setRight(new TNode(11));
    node.getLeft().setLeft(new TNode(14));
    node.getRight().setRight(new TNode(1));
    node.getRight().setLeft(new TNode(50));
    ArrayList arrayList=new ArrayList();
    arrayList.add(1);
    arrayList.add(9);
    arrayList.add(4);
    arrayList.add(14);
    arrayList.add(11);
    arrayList.add(1);
    arrayList.add(50);

//    assertEquals( " 1 9 4 14 11 50 1",tree.breadthFirstTraverse(node));
    assertEquals(arrayList ,tree.Breadth1stTraverse(tree));
  }


  @Test
  void oddSumTest(){
    BinaryTree tree = new BinaryTree();
    TNode node = new TNode(1);
    node.setRight(new TNode(4));
    node.setLeft(new TNode(9));
    node.getLeft().setRight(new TNode(11));
    node.getLeft().setLeft(new TNode(14));
    node.getRight().setRight(new TNode(1));
    node.getRight().setLeft(new TNode(50));

    assertEquals(22, tree.sumOfOddNums(node));
  }

}


class inser{
  @Test
  void insertTest(){
    SortInsertion insertion = new SortInsertion();
    int arr[] = {8,4,23,42,16,15};
   String res = insertion.insert(arr);
    assertEquals("[42, 23, 16, 15, 8, 4]",res);
  }



  @Test
  void mergeSort(){
    MergeSort mergeSort = new MergeSort();
    int arr[] = {8,4,23,42,16,15};

 mergeSort.mergeSort(arr);
   String res = Arrays.toString(arr);
    assertEquals("[4, 8, 15, 16, 23, 42]" , res);
  }

@Test
  void quickSortTest(){
  int arr[] = {8,4,23,42,16,15};
  QuickSort quickSort=new QuickSort();
  quickSort.quickSort(arr,0,arr.length-1);

  String res= Arrays.toString(arr);
  assertEquals("[4, 8, 15, 16, 23, 42]",res);
}


@Test
  void newQuickTest(){
  int arr[] = {8,4,23,1,42,16,15};
  QuickSort quickSort=new QuickSort();
  quickSort.quickSort(arr,0,arr.length-1);

  String res= Arrays.toString(arr);
  assertEquals("[1, 4, 8, 15, 16, 23, 42]",res);
}
}


class HashTableTests{
  @Test
  void addTest(){
    HashTable<String,Integer> hashTable= new HashTable<>();
    hashTable.add("Mariam" , 811);
    Integer key = hashTable.get("Mariam");

    assertEquals(811 ,key);

  }

  @Test
  void getTest(){
    HashTable<String,Integer> hashTable= new HashTable<>();
    hashTable.add("Mariam" , 811);
    Integer key = hashTable.get("Mariam");

    assertEquals(811 ,key);
  }

  @Test
  void removeTest(){
    HashTable<String,Integer> hashTable= new HashTable<>();
    hashTable.add("Mariam" , 811);

    assertEquals(811, hashTable.remove("Mariam"));
    assertEquals(0 ,hashTable.size());
  }

  @Test
  void removeNotFoundKey(){
    HashTable<String,Integer> hashTable= new HashTable<>();
    hashTable.add("Mariam" , 811);

    assertNull(hashTable.remove("sara"));

  }

  @Test
  void addSameKeyToHashTable(){
    HashTable<String,Integer> hashTable= new HashTable<>();
    hashTable.add("Mariam" , 811);
    hashTable.add("Mariam" , 12);
    assertEquals("12",hashTable.get("Mariam"));

  }


  @Test
  void doesContain() throws Exception {
    HashTable<String,Integer> hashTable= new HashTable<>();
    hashTable.add("Mariam" , 811);
    hashTable.add("Sara" , 811);
    hashTable.add("Yousef" , 811);
    assertTrue(hashTable.contains("Yousef"));
//    assertTrue(hashTable.contains("nan"));
  }



  @Test
  void checkRepeatedTest() throws Exception {
    String string = "A strawberry is a strawberry";
    HashTable<String,Integer> hashTable= new HashTable<>();

    assertEquals("it", hashTable.checkRepeated("It was the best of times, it was the worst of times, " +
      "it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch " +
      "of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, " +
      "it was the winter of despair, we had everything before us, we had nothing before us, we were all going " +
      "direct to Heaven, we were all going direct the other way – in short, the period was so far like the present " +
      "period, that some of its noisiest authorities insisted on its being received, for good or for evil, " +
      "in the superlative degree of comparison only..."));
  }
  @Test
  void checkSecond() throws Exception {
    String string = "A strawberry is a strawberry";
    HashTable<String,Integer> hashTable= new HashTable<>();
    assertEquals("a" ,hashTable.checkRepeated(string));
  }

}

  class TreeIntersection {
    TNode binaryTreeNode;
    BinaryTree binaryTree;
    TNode binaryTreeNode2;
    BinaryTree binaryTree2;

    @BeforeEach
    void createTree() {

      binaryTreeNode = new TNode(1);
      binaryTree = new BinaryTree(binaryTreeNode);

      binaryTreeNode.setLeft(new TNode(2));
      binaryTreeNode.setRight(new TNode(3));
      binaryTree.getRoot().getLeft().setLeft(new TNode(4));
      binaryTree.getRoot().getLeft().setRight(new TNode(5));
      binaryTree.getRoot().getRight().setLeft(new TNode(6));
      binaryTree.getRoot().getRight().setRight(new TNode(7));

      // second tree
      binaryTreeNode2 = new TNode(8);
      binaryTree2 = new BinaryTree(binaryTreeNode2);

      binaryTreeNode2.setLeft(new TNode(9));
      binaryTreeNode2.setRight(new TNode(6));
      binaryTree2.getRoot().getLeft().setLeft(new TNode(10));
      binaryTree2.getRoot().getLeft().setRight(new TNode(4));
      binaryTree2.getRoot().getRight().setLeft(new TNode(11));
      binaryTree2.getRoot().getRight().setRight(new TNode(12));


    }

    @Test
    void TreeIntersectionTest() {

      String expected = HashTable.treeIntersection(binaryTreeNode, binaryTreeNode2).toString();
      assertEquals("[4, 6]", expected);


    }

    @Test
    void testEmptyTree() {
      TNode binaryTreeNode3 = new TNode();
      BinaryTree binaryTree4 = new BinaryTree();
      String exp = HashTable.treeIntersection(binaryTreeNode3, binaryTreeNode2).toString();
      assertEquals("[]", exp);
    }


    @Test
    void leftJoinTest() {
      LeftJoins leftJoins = new LeftJoins();
      HashMap<String, String> h1 = new HashMap<>();
      HashMap<String, String> h2 = new HashMap<>();
      h1.put("Mariam", "hello");
      h1.put("Yousef", "hello2");
      h1.put("Sara", "hello3");

      h2.put("Mariam", "hello4");
      h2.put("Yousef", "hello5");
      h2.put("Dana", "hello6");

      HashTable<String, String[]> hashtable = HashTable.leftJoin(h1, h2);

      final ByteArrayOutputStream outContent = new ByteArrayOutputStream();
      System.setOut(new PrintStream(outContent));


    }

    @Test
    void commonWord() throws Exception {
      CommonWord newInstance= new CommonWord();
      String str= "we are far far away from each other";
      String expected = newInstance.mostCommonWord(str);
      assertEquals("far" ,expected );
    }

    @Test
    void NocommonWord() throws Exception {
      CommonWord newInstance= new CommonWord();
      String str= "we are far away from each other";
      String expected = newInstance.mostCommonWord(str);
      assertEquals("" ,expected );
    }

    @Test
    void moreCommonWord() throws Exception {
      CommonWord newInstance= new CommonWord();
      String str= "we are far far away from from  each other";
      String expected = newInstance.mostCommonWord(str);
      assertEquals("far" ,expected );
    }


  }

  class Graph{
  @Test void breadthFirstTestGetName(){
    graphs.Graph<String> graph = new graphs.Graph<>();

    Vertex<String> vertex1 = graph.addNode("Mariam");
    Vertex<String> vertex2 = graph.addNode("Yousef");
    Vertex<String> vertexA = graph.addNode("Lora");
    Vertex<String> vertex3 = graph.addNode("Sara");
    graph.addEdge(vertex1,vertex2,1);
   HashSet<Vertex<String>> res= graph.breadthFirst(vertexA);
    assertEquals("Yousef",res.iterator().next().getValue());
  }


  @Test
    void breadthFirstTraversalTest(){
    graphs.Graph<String> graph = new graphs.Graph<>();
//    Vertex<String> vertex1 = graph.addNode("1");
//    Vertex<String> vertex2 = graph.addNode("2");
//    Vertex<String> vertexA = graph.addNode("3");
//    Vertex<String> vertex3 = graph.addNode("4");
    //add edges to the vertex
//    graph.addEdge(vertex1,vertex2,1);
//    graph.addEdge(vertex1,vertexA,3);
//    graph.addEdge(vertex2,vertex3,2);
//    graph.addEdge(vertex3,vertex2,2);
    Vertex<String> vertex1 = graph.addNode("Mariam");
    Vertex<String> vertex2 = graph.addNode("Yousef");
    Vertex<String> vertex3 = graph.addNode("Sara");
    Vertex<String> vertex4 = graph.addNode("Lora");
    graph.addEdge(vertex3,vertex2,1);
    graph.addEdge(vertex2,vertex1,5);
    graph.addEdge(vertex2,vertex4,5);

    ArrayList <String>arr= new ArrayList<>();
HashSet<Vertex<String>> res= graph.breadthFirst(vertex1);
    for(Vertex<String> node: res){
      arr.add(node.getValue());

    }
    assertEquals("[1, 2, 3, 4]", arr.toString());
  }



  @Test
    void depthFirstTraverse() {
    graphs.Graph<String> graph = new graphs.Graph<>();
    Vertex<String> vertex1 = graph.addNode("Mariam");
    Vertex<String> vertex2 = graph.addNode("Yousef");
    Vertex<String> vertex3 = graph.addNode("Sara");
    Vertex<String> vertex4 = graph.addNode("Lora");
    graph.addEdge(vertex3, vertex2, 1);
    graph.addEdge(vertex2, vertex1, 5);
    graph.addEdge(vertex2, vertex4, 5);
    ArrayList<String> arr = new ArrayList<>();
    HashSet<Vertex<String>> res = graph.depthFirst(vertex3);
    for (Vertex<String> node : res) {
      arr.add(node.getValue());
      assertEquals("", arr.toString());
    }
  }

  @Test  void tripCostTest(){
    graphs.Graph<String> graph = new graphs.Graph<>();
    Vertex<String> v1=  graph.addNode("Mariam");
  Vertex<String> v2=graph.addNode("Sara");
  Vertex<String> v3=graph.addNode( "Lora");
  Vertex<String> v4=graph.addNode( "Yousef");

graph.addEdge(v1,v4,150);
graph.addEdge(v1,v2,60);
graph.addEdge(v2,v3,40);

String[] cityNames = {"Mariam","Lora"};

assertEquals("FALSE, 0",graph.businessTrip(graph,cityNames));
  }


  }



